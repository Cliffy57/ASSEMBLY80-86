PILE SEGMENT PARA STACK 'PILE'	;ON DEFINI LA PILE
        DW 512 DUP(00) 		; DEFINE ONE WORD 512
PILE  ENDS
													;10 = RETOUR A LA LIGNE
													;$ = VALEUR ACTUELLE DU COMPTEUR D'EMPLACEMENT
DONNEE SEGMENT
	TITRE_1		DB	'I-------------------------------------I',10,'$'
	TITRE_2		DB	'I   DI PAOLO HUGO X DI TULLIO LOUIS   I',10,'$'
	TITRE_3		DB	'I         \\\ CALCULATRICE ///        I',10,'$'
	TITRE_4		DB	'I       /// ASSEMBLEUR X8086 \\\      I',10,'$'
	TITRE_5		DB	'I-------------------------------------I',10,'$'
	_MENU			DB	' 1:(+) 2:(-) 3:(*) 4:(/) ',10,'CHOISISSEZ VOTRE OPERATION: $'
	
	ESPACE				DB	'   $'
	POUR_ADD			DB	10,' + $'
	POUR_SOUS			DB	10,' - $'
	POUR_MUL			DB	10,' * $'
	POUR_DIV			DB	10,' / $'
	EGAL				DB 10,' = $'
	DIVZERO			DB	'DIVISION PAR 0 INTERDIT !$'
	QUITTER			DB	'  VOULEZ VOUS QUITTER LE PROGRAMME ? $',10 ;DEFINE BYTE. 8 BITS
	CHOIX    DB  '	 - OUI OU NON (O/N)? $'
	OK		DB 	13						;CARRIAGE RETURN NO LINE FEED 13 en ASCII CR = TOUCHE ENTREE
	DEL		DB	8							;ON ASSIGNE 8 A DELETE (BACKSPACE POUR SUPPRIMER LORS DE LA SAISIE DES OPERANDES)
	DELETE	DB	8,' ',8,'$'
DONNEE ENDS


CODE SEGMENT 

	LB PROC NEAR 						;RETOUR A LA LIGNE
			PUSH AX 						;STORES 16 BIT VALUE IN THE STACK.
			PUSH DX 						;PUSH AND POP WORK WITH 16 BIT VALUES ONLY!
			MOV DL,10
			MOV AH,2
			INT 21H
			POP DX
			POP AX 							;GETS 16 BIT VALUE FROM THE STACK.
			RET 								; TRANSFERS CONTROL TO THE RETURN ADDRESS LOCATED ON THE STACK
	LB ENDP

	SCANENTIER	PROC NEAR
													;OUTPUT DI
		ASSUME CS:CODE,DS:DONNEE ;DIRECTIVE TELLS THE ASSEMBLER TO ASSUME, THAT A CERTAIN REGISTER CONTAINS THE BASE OF SOME STRUCTURE(IN YOUR CASE: SEGMENTS). IN YOUR CASE, CS AND DS POINT TO THE CODE SEGMENT AND THE DATA SEGMENT RESPECTIVELY, BOTH THE ONE AND ONLY OF THEIR RESPECTIVE KIND. SO CS IS ALREADY ASSUMED AS A POINTER TO THE CODE SEGMENT, BECAUSE THE CODE SEGMENT IS THE ONLY ONE. SO IS DS
			PUSH AX
			PUSH BX
			PUSH CX
			PUSH DX
			MOV DI,0
			MOV CX,4						;NOMBRE DE CHIFFRES PAR OPERANDES MAXIMUM
			SI_READ_CHAR:
				MOV AH,8					; ON ASSIGNE 8 A AH DONC ON DELETE
				INT 21H
				
				CMP AL,DEL 				;COMPARE AL A DEL
				JE SI_ACTION_DEL  ;JE = ZÉRO (EGAL)
				CMP AL,OK 				;COMPARE AL A OK
				JE SI_ACTION_OK 	;JE = ZÉRO (EGAL)
				CMP CX,0 
				JE SI_READ_CHAR		;INTERRUPTION EN CAS DE CARACTERES NON AUTORISE
				CMP AL,'0' 				;COMPARE AL A LA VALEUR 0
				JB SI_READ_CHAR		;JB = INFÉRIEUR -> JUMP
				CMP AL,'9' 				;COMPARE AL A LA VALEUR 9
				JA SI_READ_CHAR		;JA = SUPÉRIEUR -> JUMP
				MOV DL,AL
				MOV AH,2
				INT 21H
				SUB AL,'0'				;PASSE DU DEC AU CHAR
													;DI=NOMBRE  AL=DIGIT
				MOV BL,AL					;BL=DIGIT
				MOV AX,10 				;ASSIGNE LA DIXAINE EX:10+0 = 10	
				MUL DI						;DX:AX=DI X 10
				ADD AL,BL					;AX = AX + DIGIT
				MOV DI,AX
													;DI=NOMBRE
				DEC CX
				
			JMP SI_READ_CHAR
			
		SI_ACTION_DEL:
			CMP CX,4
			JNB SI_READ_CHAR		; JNB = PAS INFÉRIEUR
			LEA DX, DELETE
			MOV AH,9
			INT 21H
													;DI = NOMBRE
			MOV DX,0
			MOV AX,DI
			MOV BX,10
			DIV BX							;DX:AX DIV BX => AX (MOD => DX)
			MOV DI,AX						;DI <= DI DIV 10
			INC CX
			JMP SI_READ_CHAR
		
		SI_ACTION_OK:
			CMP CX,4
			JNE SI_FIN
			MOV DL,'0'
			MOV AH,2
			INT 21H		
			
		SI_FIN:
			POP DX							;POP WORD OFF STACK
			POP CX							;DÉSEMPILE DU SOMMET DE LA PILE UNE VALEUR ET LA MET DANS UN EMPLACEMENT MÉMOIRE OU REGISTRE
			POP BX 							;CETTE INSTRUCTION PERMET DE DÉSEMPILER DE LA PILE UN MOT, UN DOUBLE MOT OU UN QUADRUPLE MOT ET LA MET DANS UNE OPÉRANDE.
			POP AX
			RET
	SCANENTIER	ENDP

	TRMTENT16	PROC NEAR
													;INPUT DI
			PUSH AX
			PUSH BX
			PUSH CX
			PUSH DX
			
			MOV CX,0
			MOV AX,DI
			MOV BX,10 					;8 POUR OCTAL			
		T16CALC_DIGITS: 			;CONVERTIT EN  16 BITS
			MOV DX,0
			DIV BX
			PUSH DX
			INC CX
			CMP AX,0
			JNE T16CALC_DIGITS
		
		T16AFF_DIGITS: 				;AFFICHE EN 16 BITS
			POP DX
			ADD DL,'0'
			MOV AH,2
			INT 21H
			LOOP T16AFF_DIGITS
			
			POP DX 
			POP CX
			POP BX
			POP AX
			RET
	TRMTENT16 ENDP

	TRMTENT32	PROC NEAR 		;MULTIPLICATION CAR 32 BITS

		PUSH AX
		PUSH BX
		PUSH CX
		PUSH DX
		PUSH SI
		PUSH DI
													;INPUT SI:DI
			MOV DX,SI
			MOV AX,DI
			MOV BX, 10000
			DIV BX 							;-> 4 DU HAUTS = AX ;; 4 DU BAS = DX 
			
			MOV SI,AX						;SAUVEGARDE LE HAUT 
			MOV AX,DX						;CHARGE LE BAS DANS AX
			
			MOV CX,0
			MOV BX,10
													;SUR LE BAS
		T32BAS:
			MOV DX,0
			DIV BX
			PUSH DX
			INC CX
													;TANT QUE AX =! 0 OU (SI =! 0 ET CX < 4)
			CMP AX,0
			JNE T32BAS
			CMP CX,4
			JAE T_32HAUT				;JAE = 	SUPÉRIEUR OU ÉGAL
			CMP SI,0
			JNE T32BAS
		
		T_32HAUT:
			MOV AX,SI
			T32HAUT:
				CMP AX,0
				JE T32AFF
				MOV DX,0
				DIV BX
				PUSH DX
				INC CX
				JMP T32HAUT
			
		T32AFF:
			POP DX
			ADD DL,'0'
			MOV AH,2
			INT 21H
			LOOP T32AFF
			POP DI
			POP SI
			POP DX
			POP CX
			POP BX
			POP AX
			RET
	TRMTENT32 ENDP

	PROG_ADDITION PROC NEAR
			PUSH AX
			PUSH DX
			PUSH SI 						;SOURCE INDEX POINTS TO A SOURCE IN STREAM OPERATIONS
			PUSH DI 						;DESTINATION INDEX POINTS TO A DESTINATION IN STREAM OPERATIONS
													;'   ' ESPACE
			LEA DX,ESPACE 			;CHARGE L ADDRESSE EFFECTIVE DANS DX
			MOV AH,9
			INT 21H
													;OPERANDE 1 DANS SI
			CALL SCANENTIER
			MOV SI,DI
													;' + '
			LEA DX,POUR_ADD
			MOV AH,9 
			INT 21H
													;OPERANDE 2 DANS DI
			CALL SCANENTIER
													;' = '
			LEA DX,EGAL
			MOV AH,9
			INT 21H		
													;RESULTAT	  
			ADD DI,SI
			CALL TRMTENT16
			CALL LB
			
			POP DI
			POP SI
			POP DX
			POP AX
			RET
	PROG_ADDITION ENDP

	PROG_SOUSTRACTION PROC NEAR
			PUSH AX
			PUSH DX
			PUSH SI
			PUSH DI
													;'   ' ESPACE
			LEA DX,ESPACE
			MOV AH,9
			INT 21H
													;OPERANDE 1 DANS SI
			CALL SCANENTIER
			MOV SI,DI
													;' - '
			LEA DX,POUR_SOUS
			MOV AH,9 
			INT 21H
													;OPERANDE 2 DANS DI
			CALL SCANENTIER
													;' = '
			LEA DX,EGAL
			MOV AH,9
			INT 21H						
													;RESULTAT
			SUB SI,DI
			JNS S_STRTMNT
													;RESULTAT NEGATIF
				MOV DL,'-' 
				MOV AH,2   
				INT 21H
				NEG SI
			S_STRTMNT: 
				MOV DI,SI
				CALL TRMTENT16
				CALL LB
			
			POP DI
			POP SI
			POP DX
			POP AX
			RET 								;CETTE INSTRUCTION PERMET DE QUITTER UNE PROCÉDURE.
	PROG_SOUSTRACTION ENDP

	PROG_MULTIPLICATION PROC NEAR
													;MUL SOURCE ->>  DX:AX = AX * SOURCE
			PUSH AX
			PUSH DX
			PUSH SI
			PUSH DI
													;'   '
			LEA DX,ESPACE
			MOV AH,9
			INT 21H
													;NBR 1 DANS SI
			CALL SCANENTIER
			MOV SI,DI
													;' X '
			LEA DX,POUR_MUL
			MOV AH,9 
			INT 21H
													;NBR 2 DANS DI
			CALL SCANENTIER
													;' = '
			LEA DX,EGAL
			MOV AH,9
			INT 21H						
													;RESULTAT
			MOV AX,SI
			MUL DI 							;-> DX : AX = AX * DI
			MOV SI,DX
			MOV DI,AX
			CALL TRMTENT32
			CALL LB
			POP DI
			POP SI
			POP DX
			POP AX
			RET
	PROG_MULTIPLICATION ENDP

	PROG_DIVISION PROC NEAR
		PUSH AX
		PUSH CX
		PUSH DX
		PUSH DI
		PUSH SI	
													;'   ' ESPACE
			LEA DX,ESPACE
			MOV AH,9
			INT 21H
													;NBR 1 DANS SI
			CALL SCANENTIER
			MOV SI,DI
													;' / '
			LEA DX,POUR_DIV
			MOV AH,9 
			INT 21H
													;NBR 2 DANS DI
			CALL SCANENTIER
													;' = '
			LEA DX,EGAL
			MOV AH,9
			INT 21H	
			
													;DIV PAR ZERO
			CMP DI,0
			JNE PDIV_PASDIVZERO
			LEA DX,DIVZERO
			MOV AH,9
			INT 21H
			JMP PDIV_FIN
		PDIV_PASDIVZERO: 			;CALCUL DES RESULTATS
			MOV DX,0
			MOV AX,SI
			DIV DI 							;DIV DI ->> DX:AX / DI >> QUOTIENT = AX , RESTE = DX
			MOV SI,DI
			MOV DI,AX
			CALL TRMTENT16
													;PARTIE APRES LA VIRGULE
			CMP DX,0
			JE PDIV_FIN
			
			PUSH DX
			MOV DL,'.'					;AFFICHAGE DE LA VIRGULE
			MOV AH,2
			INT 21H
			POP DX
			MOV CX,2
			PDIV_VIR:						;4 CHIFFRES APRES LA VIRGULE : AX -> 100 
				MOV AX,100				;AX ->  CHIFFRES APRES LA VIRGULE
				MUL DX
				DIV SI
				MOV DI,AX
				CALL TRMTENT16
				LOOP PDIV_VIR
		
		PDIV_FIN:
			CALL LB
			POP SI
			POP DI
			POP DX
			POP CX
			POP AX
			RET
	PROG_DIVISION ENDP

	PROG    PROC NEAR
					ASSUME CS:CODE	;DS:DONNEE;SS:PILE;ES:RIEN
					MOV AX,DONNEE
					MOV DS,AX
			
													;AFFICHAGE DE L'ENTETE
					MOV AH,9
					LEA DX,TITRE_1
					INT 21H
					LEA DX,TITRE_2
					INT 21H
					LEA DX,TITRE_3
					INT 21H
					LEA DX,TITRE_4
					INT 21H
					LEA DX,TITRE_5
					INT 21H
				
			P_MENU:							;AFFICHAGE DU MENU			
					MOV AH,9
					LEA DX,_MENU
					INT 21H
													;CHOIX DE LA SELECTION
					MOV AH,1
					INT 21H
					CALL LB
													;TEST DE LA SELECTION
			P_ADDITION: 				;COMP POUR SAVOIR SI :
					CMP AL,'1'
					JNE P_SOUSTRACTION
					CALL PROG_ADDITION
					JMP P_REPEAT
			P_SOUSTRACTION:
					CMP AL,'2'
					JNE P_MULTIPLICATION
					CALL PROG_SOUSTRACTION
					JMP P_REPEAT
					
			P_MULTIPLICATION:
					CMP AL,'3'
					JNE P_DIVISION
					CALL PROG_MULTIPLICATION
					JMP P_REPEAT
			P_DIVISION:
					CMP AL,'4'
					JNE P_DIVISION
					CALL PROG_DIVISION
					JMP P_REPEAT
		
			P_REPEAT:
				MOV AH,9
				LEA DX, QUITTER
				INT 21H
				CALL LB
				LEA DX, CHOIX	
				INT 21H
													;SAISIE DE LA REPONSE
				MOV AH,1
				INT 21H
				CALL LB
													;TRAITEMENT DE LA REPONSE
				CMP AL,'N'
				JE P_MENU
				CMP AL,'O'
				JNE P_REPEAT
			
			P_FIN:
				MOV AX,4C00H			;RETOUR AU DOS ;AH,0;4C00 has a higher bit of 4C and 00 is the lower bit. AX can be split into a lower bit AL and a higher bit AH
				INT	21H
			
	PROG  ENDP
CODE ENDS
        END  PROG